// Lambda handler with full Cognito authentication
const { CognitoIdentityProvider } = require('@aws-sdk/client-cognito-identity-provider');

// Initialize Cognito client
const cognitoClient = new CognitoIdentityProvider({ 
  region: 'us-east-1'
});

// Environment variables
const CLIENT_ID = process.env.COGNITO_CLIENT_ID;
const CLIENT_SECRET = process.env.COGNITO_CLIENT_SECRET;
const USER_POOL_ID = process.env.COGNITO_USER_POOL_ID;

// Helper function to create HMAC for Cognito secret hash
const crypto = require('crypto');

function getSecretHash(username, clientId, clientSecret) {
  return crypto
    .createHmac('sha256', clientSecret)
    .update(username + clientId)
    .digest('base64');
}

// Helper function to create response with cache-busting
function createResponse(statusCode, data, customHeaders = {}) {
  const timestamp = Date.now();
  const responseData = {
    ...data,
    _timestamp: timestamp,
    _requestId: Math.random().toString(36).substr(2, 9)
  };
  
  return {
    statusCode,
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, Accept',
      'Cache-Control': 'no-cache, no-store, must-revalidate, private, max-age=0',
      'Pragma': 'no-cache',
      'Expires': '-1',
      'Last-Modified': new Date().toUTCString(),
      'ETag': `"${timestamp}-${Math.random().toString(36)}"`,
      'Vary': 'Accept-Encoding',
      ...customHeaders
    },
    body: JSON.stringify(responseData)
  };
}
    

    
    // Root endpointtusCode, data, customHeaders = {}) {
  const timestamp = Date.now();
  const responseData = {
    ...data,
    _timestamp: timestamp,
    _requestId: Math.random().toString(36).substr(2, 9)
  };
  
  return {
    statusCode,
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, Accept',
      'Cache-Control': 'no-cache, no-store, must-revalidate, private, max-age=0',
      'Pragma': 'no-cache',
      'Expires': '-1',
      'Last-Modified': new Date().toUTCString(),
      'ETag': `"${timestamp}-${Math.random().toString(36)}"`,
      'Vary': 'Accept-Encoding',
      ...customHeaders
    },
    body: JSON.stringify(responseData)
  };
}

// Main Lambda handler
exports.handler = async (event, context) => {
  const path = event.path || event.rawPath || '';
  const method = event.httpMethod || event.requestContext?.http?.method || 'GET';
  
  console.log(`${method} ${path}`);
  console.log('Event details:', JSON.stringify({
    path,
    method,
    headers: event.headers,
    queryStringParameters: event.queryStringParameters,
    pathParameters: event.pathParameters
  }, null, 2));
  
  const headers = {
    'Content-Type': 'application/json; charset=utf-8',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, Accept',
    'Cache-Control': 'no-cache, no-store, must-revalidate, private, max-age=0',
    'Pragma': 'no-cache',
    'Expires': '-1',
    'Last-Modified': new Date().toUTCString(),
    'ETag': `"${Date.now()}-${Math.random().toString(36)}"`,
    'Vary': 'Accept-Encoding'
  };
  
  try {
    // Handle preflight requests
    if (method === 'OPTIONS') {
      return { statusCode: 200, headers, body: '' };
    }
    
    // Parse request body - will be handled per endpoint as needed
    let requestBody = {};
    let rawBody = event.body || '';
    let isBase64 = event.isBase64Encoded || false;
    
    // Check for common problematic paths
    if (path === '/favicon.ico' || path === '/robots.txt' || path.includes('/.well-known/')) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({
          error: 'Resource not found',
          message: 'This is an API endpoint, not a web server'
        })
      };
    }
    
    // Debug endpoint to capture full request details
    if (path === '/debug' || path === '/dev/debug') {
      return createResponse(200, {
        message: 'Debug endpoint - full request details',
        event: {
          path: event.path,
          rawPath: event.rawPath,
          httpMethod: event.httpMethod,
          headers: event.headers,
          queryStringParameters: event.queryStringParameters,
          pathParameters: event.pathParameters,
          requestContext: event.requestContext,
          body: event.body ? event.body.substring(0, 500) : null,
          isBase64Encoded: event.isBase64Encoded
        }
      });
    }
    
    // Test endpoint specifically for frontend debugging
    if (path === '/test' || path === '/dev/test') {
      return createResponse(200, {
        message: 'Test endpoint for frontend debugging',
        success: true,
        data: {
          test: true,
          timestamp: new Date().toISOString(),
          random: Math.random()
        }
      });
    }
    
    // Health check endpoint
    if (path === '/health' || path === '/dev/health') {
      return createResponse(200, {
        status: 'healthy',
        service: 'law-ai-lambda',
        timestamp: new Date().toISOString(),
        version: '1.0.0',
        auth: 'Cognito integrated'
      });
    }
    
    // Direct auth endpoints (without /auth/ prefix)
    if (path === '/verifyToken' || path === '/dev/verifyToken') {
      const authHeader = event.headers.Authorization || event.headers.authorization;
      
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return {
          statusCode: 401,
          headers,
          body: JSON.stringify({
            error: 'Authorization header with Bearer token required'
          })
        };
      }
      
      const token = authHeader.substring(7);
      
      try {
        const getUserCommand = new (require('@aws-sdk/client-cognito-identity-provider').GetUserCommand)({
          AccessToken: token
        });
        
        const userInfo = await cognitoClient.send(getUserCommand);
        
        const attributes = {};
        userInfo.UserAttributes.forEach(attr => {
          attributes[attr.Name] = attr.Value;
        });
        
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            success: true,
            valid: true,
            username: userInfo.Username,
            attributes: attributes,
            user: {
              email: attributes.email,
              emailVerified: attributes.email_verified === 'true',
              sub: attributes.sub
            }
          })
        };
        
      } catch (error) {
        console.error('Token verification error:', error);
        
        return {
          statusCode: 401,
          headers,
          body: JSON.stringify({
            success: false,
            valid: false,
            error: error.name === 'NotAuthorizedException' ? 'Invalid or expired token' : 'Token verification failed',
            code: error.name
          })
        };
      }
    }
    
    // Authentication endpoints
    if (path.includes('/auth/')) {
      // Parse JSON body for auth endpoints
      try {
        if (rawBody) {
          requestBody = JSON.parse(rawBody);
        }
      } catch (e) {
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ error: 'Invalid JSON in request body' })
        };
      }
      
      // Sign In endpoint
      if (path === '/auth/signin' || path === '/dev/auth/signin') {
        const { email, username, password } = requestBody;
        const userIdentifier = email || username;
        
        if (!userIdentifier || !password) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({
              error: 'Email/username and password are required',
              received: Object.keys(requestBody)
            })
          };
        }
        
        try {
          const secretHash = getSecretHash(userIdentifier, CLIENT_ID, CLIENT_SECRET);
          
          const authParams = {
            ClientId: CLIENT_ID,
            AuthFlow: 'ADMIN_USER_PASSWORD_AUTH',
            UserPoolId: USER_POOL_ID,
            AuthParameters: {
              USERNAME: userIdentifier,
              PASSWORD: password,
              SECRET_HASH: secretHash
            }
          };
          
          const command = new (require('@aws-sdk/client-cognito-identity-provider').AdminInitiateAuthCommand)(authParams);
          const result = await cognitoClient.send(command);
          
          if (result.ChallengeName) {
            return {
              statusCode: 200,
              headers,
              body: JSON.stringify({
                success: false,
                challenge: result.ChallengeName,
                challengeParameters: result.ChallengeParameters,
                session: result.Session
              })
            };
          }
          
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              success: true,
              message: 'Authentication successful',
              accessToken: result.AuthenticationResult.AccessToken,
              idToken: result.AuthenticationResult.IdToken,
              refreshToken: result.AuthenticationResult.RefreshToken,
              expiresIn: result.AuthenticationResult.ExpiresIn
            })
          };
          
        } catch (error) {
          console.error('Cognito signin error:', error);
          
          let errorMessage = 'Authentication failed';
          if (error.name === 'NotAuthorizedException') {
            errorMessage = 'Invalid email or password';
          } else if (error.name === 'UserNotFoundException') {
            errorMessage = 'User not found';
          } else if (error.name === 'UserNotConfirmedException') {
            errorMessage = 'User account not confirmed. Please check your email for confirmation instructions.';
          }
          
          return {
            statusCode: 401,
            headers,
            body: JSON.stringify({
              error: errorMessage,
              code: error.name
            })
          };
        }
      }
      
      // Sign Up endpoint
      if (path === '/auth/signup' || path === '/dev/auth/signup') {
        const { email, password, name } = requestBody;
        
        if (!email || !password) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({
              error: 'Email and password are required'
            })
          };
        }
        
        try {
          const secretHash = getSecretHash(email, CLIENT_ID, CLIENT_SECRET);
          
          const signUpParams = {
            ClientId: CLIENT_ID,
            Username: email,
            Password: password,
            SecretHash: secretHash,
            UserAttributes: [
              {
                Name: 'email',
                Value: email
              }
            ]
          };
          
          if (name) {
            signUpParams.UserAttributes.push({
              Name: 'name',
              Value: name
            });
          }
          
          const command = new (require('@aws-sdk/client-cognito-identity-provider').SignUpCommand)(signUpParams);
          const result = await cognitoClient.send(command);
          
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              success: true,
              message: 'User registered successfully. Please check your email for confirmation instructions.',
              userSub: result.UserSub,
              codeDeliveryDetails: result.CodeDeliveryDetails
            })
          };
          
        } catch (error) {
          console.error('Cognito signup error:', error);
          
          let errorMessage = 'Registration failed';
          if (error.name === 'UsernameExistsException') {
            errorMessage = 'An account with this email already exists';
          } else if (error.name === 'InvalidPasswordException') {
            errorMessage = 'Password does not meet requirements';
          }
          
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({
              error: errorMessage,
              code: error.name
            })
          };
        }
      }
      
      // Email confirmation endpoint
      if (path === '/auth/confirm' || path === '/dev/auth/confirm') {
        const { email, confirmationCode } = requestBody;
        
        if (!email || !confirmationCode) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({
              error: 'Email and confirmation code are required'
            })
          };
        }
        
        try {
          const secretHash = getSecretHash(email, CLIENT_ID, CLIENT_SECRET);
          
          const confirmParams = {
            ClientId: CLIENT_ID,
            Username: email,
            ConfirmationCode: confirmationCode,
            SecretHash: secretHash
          };
          
          const command = new (require('@aws-sdk/client-cognito-identity-provider').ConfirmSignUpCommand)(confirmParams);
          await cognitoClient.send(command);
          
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              success: true,
              message: 'Email confirmed successfully. You can now sign in.'
            })
          };
          
        } catch (error) {
          console.error('Cognito confirm error:', error);
          
          let errorMessage = 'Confirmation failed';
          if (error.name === 'CodeMismatchException') {
            errorMessage = 'Invalid confirmation code';
          } else if (error.name === 'ExpiredCodeException') {
            errorMessage = 'Confirmation code has expired';
          }
          
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({
              error: errorMessage,
              code: error.name
            })
          };
        }
      }
      
      // Token verification endpoint
      if (path === '/auth/verify' || path === '/dev/auth/verify') {
        const authHeader = event.headers.Authorization || event.headers.authorization;
        
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
          return {
            statusCode: 401,
            headers,
            body: JSON.stringify({
              error: 'Authorization header with Bearer token required'
            })
          };
        }
        
        const token = authHeader.substring(7); // Remove 'Bearer ' prefix
        
        try {
          // Use Cognito to get user info from token
          const getUserCommand = new (require('@aws-sdk/client-cognito-identity-provider').GetUserCommand)({
            AccessToken: token
          });
          
          const userInfo = await cognitoClient.send(getUserCommand);
          
          // Extract user attributes
          const attributes = {};
          userInfo.UserAttributes.forEach(attr => {
            attributes[attr.Name] = attr.Value;
          });
          
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              success: true,
              valid: true,
              username: userInfo.Username,
              attributes: attributes,
              user: {
                email: attributes.email,
                emailVerified: attributes.email_verified === 'true',
                sub: attributes.sub
              }
            })
          };
          
        } catch (error) {
          console.error('Token verification error:', error);
          
          let errorMessage = 'Token verification failed';
          if (error.name === 'NotAuthorizedException') {
            errorMessage = 'Invalid or expired token';
          }
          
          return {
            statusCode: 401,
            headers,
            body: JSON.stringify({
              success: false,
              valid: false,
              error: errorMessage,
              code: error.name
            })
          };
        }
      }
      
      // Additional auth endpoints that frontends commonly expect
      if (path === '/auth/verifyToken' || path === '/dev/auth/verifyToken' || 
          path === '/verifyToken' || path === '/dev/verifyToken' ||
          path === '/auth/me' || path === '/dev/auth/me') {
        // Redirect to our verify endpoint logic
        const authHeader = event.headers.Authorization || event.headers.authorization;
        
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
          return {
            statusCode: 401,
            headers,
            body: JSON.stringify({
              error: 'Authorization header with Bearer token required'
            })
          };
        }
        
        const token = authHeader.substring(7); // Remove 'Bearer ' prefix
        
        try {
          // Use Cognito to get user info from token
          const getUserCommand = new (require('@aws-sdk/client-cognito-identity-provider').GetUserCommand)({
            AccessToken: token
          });
          
          const userInfo = await cognitoClient.send(getUserCommand);
          
          // Extract user attributes
          const attributes = {};
          userInfo.UserAttributes.forEach(attr => {
            attributes[attr.Name] = attr.Value;
          });
          
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              success: true,
              valid: true,
              username: userInfo.Username,
              attributes: attributes,
              user: {
                email: attributes.email,
                emailVerified: attributes.email_verified === 'true',
                sub: attributes.sub
              }
            })
          };
          
        } catch (error) {
          console.error('Token verification error:', error);
          
          let errorMessage = 'Token verification failed';
          if (error.name === 'NotAuthorizedException') {
            errorMessage = 'Invalid or expired token';
          }
          
          return {
            statusCode: 401,
            headers,
            body: JSON.stringify({
              success: false,
              valid: false,
              error: errorMessage,
              code: error.name
            })
          };
        }
      }
      
      // Other auth endpoints placeholder
      return {
        statusCode: 501,
        headers,
        body: JSON.stringify({
          error: 'Authentication endpoint not yet implemented',
          path: path,
          method: method,
          available: ['/auth/signin', '/auth/signup', '/auth/confirm', '/auth/verify'],
          debug: {
            receivedPath: path,
            includes_auth: path.includes('/auth/'),
            exact_matches: {
              signin: path === '/auth/signin' || path === '/dev/auth/signin',
              signup: path === '/auth/signup' || path === '/dev/auth/signup', 
              confirm: path === '/auth/confirm' || path === '/dev/auth/confirm',
              verify: path === '/auth/verify' || path === '/dev/auth/verify'
            }
          }
        })
      };
    }
    
    // Cases endpoint
    if (path === '/cases' || path === '/dev/cases') {
      // Mock case data with more comprehensive structure
      const mockCases = [
        {
          id: '1',
          title: 'Sample Contract Review',
          description: 'Review of employment contract for ABC Corp',
          createdAt: '2024-01-15',
          updatedAt: '2024-01-20',
          status: 'active',
          priority: 'high',
          client: 'ABC Corporation',
          type: 'Contract Review',
          documents: ['contract.pdf', 'addendum.pdf']
        },
        {
          id: '2', 
          title: 'Employment Agreement Analysis',
          description: 'Analysis of non-compete clauses in employment agreement',
          createdAt: '2024-01-10',
          updatedAt: '2024-01-15',
          status: 'completed',
          priority: 'medium',
          client: 'John Doe',
          type: 'Legal Analysis',
          documents: ['agreement.pdf']
        },
        {
          id: '3',
          title: 'Lease Agreement Dispute',
          description: 'Commercial lease dispute resolution',
          createdAt: '2024-01-20',
          updatedAt: '2024-01-25',
          status: 'in-progress',
          priority: 'high',
          client: 'XYZ Properties',
          type: 'Litigation',
          documents: ['lease.pdf', 'notice.pdf', 'response.pdf']
        }
      ];

      // Return just the array to maintain frontend compatibility with .map()
      return {
        statusCode: 200,
        headers: {
          'Content-Type': 'application/json; charset=utf-8',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization, Accept',
          'Cache-Control': 'no-cache, no-store, must-revalidate, private, max-age=0',
          'Pragma': 'no-cache',
          'Expires': '-1',
          'Last-Modified': new Date().toUTCString(),
          'ETag': `"${Date.now()}-${Math.random().toString(36)}"`,
          'Vary': 'Accept-Encoding'
        },
        body: JSON.stringify(mockCases)
      };
    }
    
    // S3 Upload endpoint
    if (path === '/s3/upload' || path === '/dev/s3/upload') {
      if (method !== 'POST') {
        return {
          statusCode: 405,
          headers,
          body: JSON.stringify({
            error: 'Method not allowed. Use POST for file uploads.'
          })
        };
      }
      
      const contentType = event.headers['content-type'] || event.headers['Content-Type'] || '';
      
      // Check if this is a JSON request for presigned URL generation
      if (contentType.includes('application/json')) {
        try {
          // Parse JSON body for presigned URL generation
          const parsedBody = rawBody ? JSON.parse(rawBody) : {};
          const { fileName, fileType, fileSize } = parsedBody;
          
          if (!fileName || !fileType) {
            return {
              statusCode: 400,
              headers,
              body: JSON.stringify({
                error: 'fileName and fileType are required for presigned URL generation'
              })
            };
          }
          
          const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');
          const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
          
          const s3Client = new S3Client({ region: 'us-east-1' });
          
          // Generate unique file name
          const timestamp = Date.now();
          const uniqueFileName = `${timestamp}-${fileName}`;
          
          // Create S3 put object command
          const command = new PutObjectCommand({
            Bucket: process.env.S3_BUCKET_NAME,
            Key: uniqueFileName,
            ContentType: fileType,
            ContentLength: fileSize
          });
          
          // Generate presigned URL for upload (expires in 1 hour)
          const uploadUrl = await getSignedUrl(s3Client, command, { expiresIn: 3600 });
          
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              success: true,
              uploadUrl,
              fileName: uniqueFileName,
              bucket: process.env.S3_BUCKET_NAME,
              fileUrl: `https://${process.env.S3_BUCKET_NAME}.s3.amazonaws.com/${uniqueFileName}`
            })
          };
          
        } catch (jsonError) {
          return {
            statusCode: 400,
            headers,
            body: JSON.stringify({
              error: 'Invalid JSON in request body',
              details: jsonError.message
            })
          };
        }
      }
      
      // Handle direct file upload (multipart/form-data or binary)
      try {
        const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');
        const s3Client = new S3Client({ region: 'us-east-1' });
        
        // Extract filename from headers or generate one
        let fileName = 'uploaded-file';
        const contentDisposition = event.headers['content-disposition'] || event.headers['Content-Disposition'];
        if (contentDisposition && contentDisposition.includes('filename=')) {
          const match = contentDisposition.match(/filename="?([^"]+)"?/);
          if (match) {
            fileName = match[1];
          }
        }
        
        // Generate unique file name
        const timestamp = Date.now();
        const uniqueFileName = `${timestamp}-${fileName}`;
        
        // Prepare file data
        let fileBuffer;
        if (isBase64) {
          fileBuffer = Buffer.from(rawBody, 'base64');
        } else {
          fileBuffer = Buffer.from(rawBody);
        }
        
        // Upload directly to S3
        const command = new PutObjectCommand({
          Bucket: process.env.S3_BUCKET_NAME,
          Key: uniqueFileName,
          Body: fileBuffer,
          ContentType: contentType || 'application/octet-stream'
        });
        
        await s3Client.send(command);
        
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            success: true,
            fileName: uniqueFileName,
            bucket: process.env.S3_BUCKET_NAME,
            fileUrl: `https://${process.env.S3_BUCKET_NAME}.s3.amazonaws.com/${uniqueFileName}`,
            size: fileBuffer.length
          })
        };
        
      } catch (error) {
        console.error('S3 upload error:', error);
        
        return {
          statusCode: 500,
          headers,
          body: JSON.stringify({
            error: 'Failed to upload file',
            details: error.message
          })
        };
      }
    }
    
    // Root endpoint
    if (path === '/' || path === '/dev' || path === '/dev/') {
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({
          message: 'Law-AI API with Cognito Authentication',
          timestamp: new Date().toISOString(),
          status: 'Production Ready',
          available_endpoints: ['/health', '/auth/signin', '/auth/signup', '/auth/confirm', '/auth/verify', '/cases', '/s3/upload'],
          authentication: 'AWS Cognito integrated'
        })
      };
    }
    
    // Default 404 for unhandled routes
    console.log('Unhandled route - Path:', path, 'Method:', method, 'Headers:', JSON.stringify(event.headers, null, 2));
    return {
      statusCode: 200, // Return 200 to ensure this gets through
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        error: 'Route not found but returning 200 for debugging',
        path: path,
        method: method,
        fullEvent: {
          path: event.path,
          rawPath: event.rawPath, 
          httpMethod: event.httpMethod,
          headers: event.headers,
          queryStringParameters: event.queryStringParameters,
          pathParameters: event.pathParameters,
          body: event.body ? (event.body.length > 500 ? event.body.substring(0, 500) + '...' : event.body) : null
        },
        debug: {
          availableRoutes: [
            'GET /health',
            'GET /',
            'GET /debug',
            'POST /auth/signin',
            'POST /auth/signup', 
            'POST /auth/confirm',
            'GET /auth/verify',
            'GET /verifyToken',
            'GET /cases',
            'POST /s3/upload'
          ]
        }
      }, null, 2)
    };
    
  } catch (error) {
    console.error('Handler error:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: 'Internal server error',
        message: error.message
      })
    };
  }
};